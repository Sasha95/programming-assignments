\section{Массивы и коллекции}


\subsection{Одномерные массивы}

\task Написать программу, выполняющую вейвлет-преобразование Хаара для
заданного массива с длиной, равной степени $2$. Само преобразование
выполняется следующим образом. В первую половину массива записываются
полусуммы пар соседних элементов, а во вторую — полуразности. После
этого преобразование повторяется для первой половины массива до тех
пор, пока не останется только одна полусумма.

Например, для массива $(2, 8, 6, 0)$ после первого шага получим
\[
\left(\frac{2+8}2, \frac{6+0}2, \frac{2-8}2, \frac{6-0}2\right) = (5, 3, -3, 3).
\]
На втором шаге преобразование будет применено только к полусуммам —
$(5, 3)$. В итоге получим массив
\[
\left(\frac{5+3}2, \frac{5-3}2, -3, 3\right) = (4, 1, -3, 3).
\]
Так как осталась одна полусумма, это и есть ответ.

\task Написать программу, проверяющую, образуют ли элементы массива
периодическую последовательность и найти её период.

Например, в массиве $(1, 2, 3, 1, 2, 3)$ длина периода равна $3$.

\task Написать программу, заменяющую все составные числа в массиве
последовательных чисел от $2$ до указанного числа нулями при помощи
алгоритма, называемого решетом Эратосфена. Идея алгоритма следующая:
перебираются все элементы, если элемент не нулевой, то заменяютя
нулями все, идущие после него с шагом, равным значению этого
элемента. Алгоритм продолжается до элемента со значением
$\left\lceil\sqrt N\right\rceil,$ где $N$ — значение последнего
элемента.

Например, для массива $(2, 3, 4, 5, 6, 7, 8, 9)$ последовательность
преобразований имеет вид (текущий элемент подчёркнут):
\begin{eqnarray*}
&(\underline2, 3, \cancel4, 5, \cancel6, 7, \cancel8, 9),\\
&(2, \underline3, 0, 5, \cancel0, 7, 0, \cancel9),\\
&(2, 3, \underline0, 5, 0, 7, 0, 0).
\end{eqnarray*}

\task Написать программу для так называемой «пузырьковой сортировки»
массива по неубыванию. Идея метода следующая. Просматриваются все пары
соседних элементов и, если их порядок неверный, они обмениваются
местами. Проходы по массиву повторяются, пока не окажется, что массив
отсортирован.

\task Написать программу для сортировки массива по неубыванию простым
выбором. Идея метода следующая. В массиве ищется наименьший элемент и
меняется местами с первым, затем наименьший среди оставшихся меняется
местами со вторым и так далее.

\task Написать программу, переставляющую элементы массива так, чтобы
сначала были записаны значения, меньшие некоторого числа $p$, потом
равные ему, а затем остальные.

\task Написать программу, реализующую так называемое правило~30 для
клеточных автоматов. Дан массив заданной длины, элементы которого
равны нулю кроме среднего, который равен единицы. Программа должна
выполнить указанное число шагов преобразований массива выводя на
каждом шаге результат.

В ходе преобразования проверяются все ячейки массива, кроме
крайних. На следующем шаге ячейка становится равной $1$ тогда и только
тогда, когда она со своими соседями образует одну из четырёх
комбинаций: $100$, $010$, $001$ или $011$. В противном случае ячейка
на новом шаге будет равна $0$.

Например для массива размера $7$ первые три шага имеют вид:
\begin{eqnarray*}
&0001000,\\
&0011100,\\
&0110010.
\end{eqnarray*}

\task Написать программу, разбивающую массив на три подмассива с
сохранением порядка. При этом суммы элементов в них должны быть как
можно ближе друг к другу: разница между наибольшей и наименьшей
суммами должна быть минимальной. Программа должны вывести номера
первых элементов второго и третьего подмассивов.

Например, массив $(1, 2, 3, 2, 2)$ разбивается на подмассивы $(1, 2)$,
$(3)$ и $(2, 2).$ Если элементы нумеруются с нуля, то искомые индексы
— 2 и 3.

\task Написать программу, находящую максимальное значение, которое
можно получить, складывая последовательные элементы массива. Например,
для массива $(1, -2, 3, 1, -1, 2)$ максимальная сумма равна
$3+1+(-1)+2=5$.

\task Написать программу для тернарного поиска элемента в
отсортированном массиве. Алгоритм похож на бинарный поиск. Массив
делится двумя точками на три части приблизительно равного
размера. Затем сравнивая искомое значение со значениями в точках,
определяем, в какой из частей оно находится. Затем поиск повторяется в
этой части, и так далее, пока не будет найден элемент или не окажется,
что его нет в массиве.


\subsection{Многомерные массивы}

\task Дан двумерный массив целых чисел. Заменить нулями элементы,
стоящие в строках и столбцах, в которых есть нулевые элементы.

\task Дан двумерный массив действительных чисел. Заменить каждый элемент
арифметическим средним его смежных соседей по горизонтали, вертикали и
диагонали.

\task Дан двумерный массив размера $M\times N$ действительных
чисел. Нормировать его по формуле
\[
a_{ij}^\textrm{норм} = \frac{a_{ij}-\bar{a}}{\sigma},
\]
где $\bar{a}$ — математическое ожидание, а $\sigma$ — стандартное
отклонение, вычисляемые по формулам
\begin{align*}
  \bar{a} &= \frac{1}{MN}\sum_{i,j}a_{ij},\\
  \sigma  &= \sqrt{\frac{1}{MN}\sum_{i,j}(a_{ij}-\bar{a})^2}. 
\end{align*}

\task Дан двумерный массив действительных чисел. Проверить, есть ли в
нём линейно зависимые строки и столбцы.

\task Заполнить двумерный массив указанного размера последовательными
натуральными числами двигаясь от верхнего левого элемента вправо и
далее по спирали.

Пример заполнения для массива $3\times 3$:
\[
\begin{array}{ccc}
  1 & 2 & 3 \\
  8 & 9 & 4 \\
  7 & 6 & 5
\end{array}
\]

\task Дан двумерный массив целых чисел. Проверить, сколько в нём
квадратов размера $2\times 2$, состоящих только из чётных элементов.

\task Дан квадратный массив действительных чисел. Сформировать массив
с суммами элементов на его диагоналях.

\task Даны две двумерные матрицы. Найти их произведение, если это
возможно.

\task Дан двумерный массив вещественных чисел. Заменить каждый его
элемент арифметическим средним элементов ниже и правее него.

\task Дан двумерный массив. Записать его элементы в одномерный массив
по строкам. При этом нечётные строки обходятся слева направо, а чётные
справа налево.

\subsection{Коллекции и их применение}

\task Дана последовательность, содержащая шесть видов скобок: (, ), [,
], \{, \}. Написать программу, проверяющую, является ли скобочная
запись, задаваемая последовательностью, корректной. Иными словами,
программа должна проверить правильность вложенности пар скобок,
отсутствие «незакрытых» и лишних «закрывающих» скобок.

Например, последовательность «([]\{\})» корректна, а «)[\{]\}» нет.

\task Дана закодированная последовательность чисел. Написать
декодирующую программу, работающую по следующему алгоритму. Если
очередное число $x$ положительное, то оно копируется в декодированную
последовательность, если отрицательное, то копируется $|x|$ последних
значений из декодированного потока.

Например, последовательность $(1, 2, 3, -2, -3)$ будет декодирована как
$(1, 2, 3, 2, 3, 3, 2, 3).$

\task Написать программу, заменяющую каждый элемент последовательности
чисел на индекс его первого вхождения.

\task Написать программу, проверяющую, верно ли, что количество
повторов какого-либо элемента последовательности равно его значению.

Например, последовательность $(4, 2, 4, 2, 4, 1, 4)$ удовлетворяет
этому условию.

\task Написать программу, которая каждый элемент последовательности
повторяет столько раз, сколько он встречался до этого.

Например, последовательность
\[
(1, 2, 1, 2, 1)
\]
будет преобразована в 
\[
(1, 2, 1, 1, 2, 2, 1, 1, 1).
\]

\task Дано клетчатое поле размера $N\times N,$ заполненное единицами и
нулями. В первой строке и первом столбце находится фигура, которая
может ходить только по вертикали или горизонтали и только на клетки, в
которых находится единица. Написать программу, определяющую сколько
клеток может посетить фигура.

Подсказка: используйте очередь для хранения координат клеток, которые
нужно проверить на возможность посещения.

Например, на поле
\[
\begin{array}{ccc}
  1 & 0 & 1 \\
  1 & 0 & 1 \\
  1 & 1 & 0
\end{array}
\]
фигура сможет посетить 4 клетки.

\task Рассмотрим приём ускорения вычислений, называемый
мемоизацией. Требуется написать функцию Apply, принимающую некоторую
функцию $f$ и число $x$. Функция $f$ принимает и возвращает
действительное число. Функция Apply должна вычислить $f(x)$ и вернуть
результат. Для ускорения расчётов все уже вычисленные значения
помещаются в словарь. Если требуется найти $f(x),$ которое уже было
посчитано ранее, функция $f$ не вызывается, а используется значение из
словаря.

Написать программу, использующую функцию Apply.

\task Рассмотрим изменённый вариант задачи Иосифа Флавия. Числа от
одного до некоторого $N$ записаны по кругу. Затем каждое $k$-е
(начиная с единицы) число вычёркивается, как в считалке с
выбыванием. Процесс продолжается, пока не останется одно
число. Написать программу, выводящую на экран последовательность
вычеркивания чисел.

Например, если $N=5,$ а $k=3$, то последовательность будет иметь вид
\[
(3, 1, 5, 2, 4).
\]

\task Даны два стека целых чисел. В первом содержатся некоторые
целочисленные значения (данные), а во втором коды команд. Команды
управляют процессом вычислений и могут быть одного из следующих видов:
\begin{itemize}
\item $1$ — взять два значения из первого стека и положить обратно
  сумму;
\item $2$ — взять два значения из первого стека и положить обратно
  разность (верхушка — уменьшаемое);
\item $3$ — поменять местами два верхних значения первого стека;
\item $4$ — скопировать значение из второго стека в первый.
\end{itemize}
Перед выполнением команды извлекаются из второго стека. Если код
команды отличается от перечисленных, она игнорируется.

Написать программу, выполняющую команды второго стека и затем
выводящую на экран верхушку первого. Если какую-то команду выполнить
невозможно — вывести на экран сообщение об ошибке.

Например, если стек данных имел вид $(3, 2, 1),$ а стек команд —
$(1, 2)$ (верхушка слева), то результатом работы программы будет число
$4$.

\task Написать программу, реализующую следующий алгоритм слияния двух
отсортированных последовательностей. Новая последовательность
формируется при помощи многократного выбора из концов заданных
исходных наименьшего элемента.


\subsection{LINQ}

\task Удвоить все элементы коллекции используя LINQ.

\task Найти корень квадратный из каждого элемента коллекции используя
LINQ.

\task В некоторой коллекции заданы углы, найти косинусы этих углов
используя LINQ.

\task Выбрать из коллекции абсолютные значения заданных в ней числовых
значений используя LINQ.

\task В некоторой коллекции заданы радиусы окружностей, найти для
каждой окружности площадь используя LINQ.

\task В некоторой коллекции заданы углы в градусах, найти значения
этих углов в радианах используя LINQ.

\task В некоторой коллекции заданы значения расстояния в метрах
перевести их в дюймы (1 дюйм = 2.54 см) используя LINQ.

\task Возвести каждый элемент коллекции в 5-ую степень используя LINQ.

\task Извлечь из каждого элемента коллекции корень 7-ой степени
используя LINQ.

\task Изменить знаки всех элементов коллекции на противоположные
используя LINQ.


\subsection{Выражения с условием}

\task В некоторой коллекции заданы радиусы окружностей, выбрать только
те, площади окружностей которых не меньше 4используя LINQ.

\task Задана коллекция углов заданных в градусах, выбрать только
острые углы, используя LINQ.

\task В некоторой коллекции заданы углы в радианах, выбрать те,
косинусы которых неотрицательны используя LINQ.

\task Выбрать из коллекции только целые двузначные числа используя
LINQ.

\task Выбрать из коллекции только четные элементы используя LINQ.

\task Выбрать из коллекции только нечетные элементы используя LINQ.

\task Выбрать из коллекции все неотрицательные значения используя
LINQ.

\task Выбрать из коллекции только числа являющиеся полными
квадратами(полные квадраты это числа арифметический корень из которых
есть целое число) используя LINQ.

\task Выбрать из коллекции только числа кратные семи используя LINQ.

\task В коллекции заданы значения углов в радианах, выбрать только
тупые углы, используя LINQ.
